Prezado(a) Aluno(a),

Este documento visa fornecer a fundamentação teórica e arquitetural necessária para o desenvolvimento inicial do **Trabalho 2: Sistema de Cotações em Tempo Real**, focando na justificação dos padrões de projeto distribuídos exigidos e nos requisitos subjacentes de comunicação e concorrência.

O objetivo do sistema é garantir altíssima disponibilidade e escalabilidade para gerenciar um volume massivo de dados de transações e distribuir preços em tempo real.

---

## I. Fundamentação Arquitetural: Mapeamento Desafio-Padrão

O projeto exige a resolução de quatro desafios arquiteturais principais, que são mitigados pela aplicação estratégica de padrões de projeto distribuídos. A tabela abaixo resume os desafios e os padrões correspondentes, conforme especificado na documentação do trabalho.

|Desafio Arquitetural (Problema)|Padrão de Projeto Distribuído|Módulo/Componente Aplicado|Justificativa Teórica (Fonte)|
|:--|:--|:--|:--|
|**1.** Banco de dados de histórico lento/grande. Necessidade de particionamento de dados.|**Particionamento (Sharding)**|Repositório de Dados Históricos|Particiona e distribui dados para gerenciar custo de armazenamento e latência de consulta.|
|**2.** Clientes precisam de aviso instantâneo de preço sem gerenciamento ativo de conexão pelo serviço.|**Publisher/Subscriber (Pub/Sub)**|Distribuição de Preços|Utiliza um _Broker_ para difundir eventos de novas cotações de forma assíncrona.|
|**3.** Motor de cotações primário depende de um serviço externo que pode falhar ou ficar lento.|**Disjuntor (Circuit Breaker)**|Serviço de Cotações em Tempo Real|Protege o serviço contra falhas externas, prevenindo falhas em cascata.|
|**4.** Necessidade de consulta complexa combinando dados em tempo real (replicados) e dados históricos (particionados).|**Scatter/Gather**|Serviço de Agregação de Consultas|Distribui consultas, coleta respostas parciais e as combina em uma resposta unificada.|

---

## II. Justificativa Detalhada dos Padrões de Projeto Distribuídos

Os padrões de projeto distribuído são soluções gerais que facilitam o desenvolvimento de sistemas complexos, oferecendo reusabilidade, manutenabilidade e comunicação eficiente, superando desafios como escalabilidade e disponibilidade.

### 1. Particionamento (Sharding)

O particionamento (Sharding) é fundamental quando o custo de armazenamento de todos os dados em uma única máquina é muito alto, ou quando a quantidade de requisições excede a capacidade de um único servidor, resultando em latência alta para consultas.

- **Problema Resolvido:** O Sharding resolve o problema do banco de dados de histórico de transações que está ficando excessivamente grande e lento, com a quantidade de requisições de consulta excedendo a capacidade de um único servidor.
- **Adoção:** Envolve particionar e distribuir os dados do sistema. As regras para distribuição podem ser definidas por **Intervalos** (e.g., dados de A-M em um _shard_ e N-Z em outro) ou por **Dispersão/Hash** (onde um hash da chave determina o _shard_). O desafio na implementação é decidir como distribuir os dados e como gerenciar a reconfiguração de partições durante a execução.
- **Contexto no Trabalho 2:** O Repositório de Dados Históricos deve implementar essa lógica para distribuir o volume massivo de transações passadas.

### 2. Publisher/Subscriber (Pub/Sub)

O padrão Pub/Sub é utilizado para difundir informações de forma assíncrona, sendo ideal para a distribuição de preços em tempo real.

- **Problema Resolvido:** Permite que componentes do sistema sejam notificados de um evento (mudança de preço) sem que o serviço de cotação precise conhecer ou gerenciar ativamente cada conexão de cliente (desacoplamento).
- **Adoção:** O sistema utiliza um **Broker** para gerenciar as mensagens. Os _Publishers_ (Serviço de Cotações) enviam mensagens associadas a um **Tópico** (e.g., o código do produto). Os _Subscribers_ (Clientes) se inscrevem em tópicos de interesse. A comunicação é tipicamente assíncrona.
- **Contexto no Trabalho 2:** Usado para a Distribuição de Preços, onde o _Broker_ gerencia e difunde eventos de novas cotações.

### 3. Disjuntor (Circuit Breaker)

O Circuit Breaker (Disjuntor) é um padrão de resiliência que previne falhas em cascata em sistemas distribuídos.

- **Problema Resolvido:** Protege o motor de cotações primário da falha ou lentidão de um serviço externo dependente. Sem este padrão, problemas de conexão levariam os clientes a esperar repetitivamente por _timeouts_, ocupando recursos críticos do cliente e do servidor (como threads e memória).
- **Adoção:** O disjuntor opera em três estados:
    1. **Closed (Fechado):** As requisições são permitidas. Se o número de falhas atingir um limiar (_threshold_), ele transiciona para o estado **Open**.
    2. **Open (Aberto):** As requisições são imediatamente rejeitadas com um erro, sem tentar se conectar ao serviço externo. Após um _timeout_ de reset, transiciona para **Half Open**.
    3. **Half Open (Semi-Aberto):** Permite que um número limitado de requisições teste se o serviço se recuperou. Em caso de sucesso, retorna ao estado **Closed**; em caso de falha, retorna a **Open**.
- **Benefícios:** Prevenção de falhas em cascata, melhoria da disponibilidade e gestão de recursos mais eficiente.

### 4. Scatter/Gather

O padrão Scatter/Gather é empregado para otimizar o desempenho de consultas complexas em arquiteturas particionadas ou replicadas.

- **Problema Resolvido:** Permite que o sistema responda rapidamente a uma consulta complexa que necessita de dados localizados em diferentes servidores (e.g., dados em tempo real em réplicas e dados históricos em _shards_).
- **Adoção:** O componente **Raiz** (_Root Node_ ou Serviço de Agregação de Consultas) recebe a requisição complexa. Ele então **dispersa** (_scatters_) requisições parciais para as réplicas ou _shards_ relevantes. Em seguida, ele **coleta** (_gathers_) as respostas parciais e as **combina** (_merges_) em uma resposta unificada para o cliente.
- **Exemplo no Trabalho 2:** A Raiz distribuiria uma parte da consulta para as réplicas (para obter o preço médio em tempo real) e outra parte para os _shards_ (para obter as últimas 10 transações históricas), combinando ambas.

---

## III. Fundamentos de Concorrência e Comunicação (Sockets em C)

Para implementar os módulos distribuídos (Servidor de Cotações, Broker, Aggregator), é essencial entender as chamadas de sistema de rede, como _sockets_, e os princípios de concorrência.

### 1. Sockets e Primitivas de Comunicação

Sockets são a abstração fundamental que permite a comunicação entre dispositivos independentes em uma rede, sendo implementados sobre a camada de transporte (TCP/UDP).

Um _socket_ é caracterizado por três atributos:

1. **Domínio / Família de Endereço:** Define o espaço de endereço (ex: `AF_INET` para Internet IPv4, `AF_INET6` para IPv6).
2. **Tipo:** Define o comportamento da comunicação (ex: `SOCK_STREAM` para conexão confiável, `SOCK_DGRAM` para datagramas).
3. **Protocolo:** (Ex: TCP, UDP).

O **Endereço de Socket** é um identificador de comunicação formado por um endereço de rede (ex: IP) e um identificador de porta local.

### 2. Comunicação Orientada a Fluxo (TCP / SOCK_STREAM)

Os _Stream Sockets_ (TCP) suportam fluxos de comunicação confiáveis e bidirecionais.

- **Garantias:** O TCP garante que os dados cheguem sequencialmente e livres de erros.
- **Uso:** Ideal para comunicação cliente-servidor onde a integridade e a ordem dos dados são cruciais (e.g., requisições de consulta complexa do cliente, mensagens de controle do _Circuit Breaker_ ou do _Broker_).
- **Primitivas Chave para Servidor TCP (Stream):**
    - `socket()`: Cria um novo descritor de socket.
    - `bind()`: Associa o socket a um endereço e porta local (ex: porta 1101 para a calculadora).
    - `listen()`: Declara que o servidor está pronto para receber conexões, especificando quantas devem ser enfileiradas (_backlog_).
    - `accept()`: Bloqueia até que uma conexão pendente na fila seja aceita, retornando um novo descritor de socket para essa comunicação específica.
    - `send()` e `recv()`: Usadas para comunicação de dados no socket conectado.

### 3. Comunicação Baseada em Datagrama (UDP / SOCK_DGRAM)

Os _Datagram Sockets_ (UDP) suportam comunicação bidirecional sem a necessidade de estabelecer ou manter conexões.

- **Garantias:** Não há garantia de que o dado será entregue, nem de que chegará na ordem correta ou sem duplicação.
- **Uso:** É a maneira mais rápida de comunicação e é usado quando a velocidade é crítica e a perda de pacotes pode ser tolerada (e.g., monitoramento de alta frequência).
- **Primitivas Chave para UDP:**
    - `socket()`: Cria o socket (usando `SOCK_DGRAM`).
    - `bind()`: Associa o socket à porta local.
    - `recvfrom()`: Recebe o pacote, bloqueando se não houver dados.
    - `sendto()`: Envia o pacote, especificando explicitamente o endereço de destino.

### 4. Concorrência para Escalabilidade

Para que o Serviço de Cotações atenda a milhões de usuários e melhore a escalabilidade, é necessário o uso de concorrência.

- **Decomposição de Tarefas vs. Dados:** A decomposição de dados é frequentemente o melhor método para obter soluções mais escaláveis em sistemas concorrentes, pois o tamanho dos dados é mais provável de aumentar do que o número de tarefas independentes. No contexto do _Sharding_, a alocação de partes da estrutura de dados para threads/processos é a **Decomposição de Dados**.
- **Estratégias de Atendimento Múltiplo:** Servidores distribuídos precisam gerenciar múltiplas conexões simultâneas.
    - **Modelo Processo/Thread por Cliente:** O servidor pode criar um novo processo filho (`fork()`) ou uma nova _thread_ para lidar com cada conexão aceita por `accept()`. Um _pool de threads_ pode ser usado para atender requisições, onde a thread principal associa o socket retornado no `accept` a uma thread disponível, controlando a disponibilidade via semáforo.
    - **Multiplexação de E/S (`select()` ou `poll()`):** Permite que um único processo/thread monitore múltiplos descritores de arquivo (sockets) simultaneamente, esperando que algum deles esteja pronto para leitura ou escrita, sem ficar bloqueado em um único socket. O uso de `poll()` é recomendado para monitorar muitos descritores de arquivos, como em aplicações que escalam para centenas de conexões.

Para o **Serviço de Agregação de Consultas** (Scatter/Gather), o uso de concorrência (múltiplas threads) ou paralelismo explícito (múltiplos processos, como em MPI, se aplicável) é essencial para distribuir as sub-requisições aos _shards_ e réplicas em paralelo e depois aguardar a coleta das respostas. O modelo de programação paralela de Passagem de Mensagens (como o MPI) é projetado para processos que possuem espaço de endereço independente.