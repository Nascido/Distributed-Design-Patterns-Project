O Sistema de Cotações em Tempo Real apresenta desafios arquitetônicos críticos relacionados à escalabilidade, disponibilidade, comunicação confiável e desempenho, que devem ser mitigados pela aplicação de Padrões de Projeto Distribuídos.

Com base na definição do Trabalho 2, os quatro desafios arquitetônicos principais e os padrões recomendados para a sua resolução são:

### 1. Escalabilidade e Latência do Repositório de Dados Históricos

- **Desafio Arquitetônico:** O banco de dados de histórico de transações está se tornando excessivamente grande e lento. A alta quantidade de requisições de consulta excede a capacidade de um único servidor, exigindo o particionamento e a distribuição dos dados para gerenciar custos de armazenamento e reduzir a latência de consultas.
- **Padrão de Projeto Recomendado:** **Particionamento (Sharding)**.
    - **Justificativa (Fonte Aula 15):** O Sharding é aplicado em situações onde o custo de armazenamento de todos os dados em uma única máquina é muito alto ou quando a quantidade de requisições excede a capacidade do servidor. Ele permite particionar e distribuir os dados do sistema.

### 2. Distribuição Assíncrona e Desacoplada de Preços

- **Desafio Arquitetônico:** Clientes requerem notificação instantânea de mudanças de preço, porém o serviço de cotação não deve precisar conhecer ou gerenciar ativamente cada conexão de cliente.
- **Padrão de Projeto Recomendado:** **Publisher/Subscriber (Pub/Sub)**.
    - **Justificativa (Fonte Aula 15):** O padrão Pub/Sub é ideal quando componentes do sistema precisam difundir informações sobre eventos (como novas cotações) para outros componentes que não são conhecidos diretamente, utilizando um _Broker_ para gerenciar as mensagens de forma assíncrona.

### 3. Proteção contra Falhas de Serviço Externo

- **Desafio Arquitetônico:** O motor de cotações primário possui dependência de um serviço externo. A falha ou lentidão deste serviço externo não pode levar à falha em cascata de todo o sistema.
- **Padrão de Projeto Recomendado:** **Circuit Breaker (Disjuntor)**.
    - **Justificativa (Fonte Aula 15/Trabalho 2):** O Circuit Breaker é usado para prevenir falhas em cascata e melhorar a disponibilidade. Ele resolve o problema de recursos críticos ficarem ocupados esperando _time-outs_ repetitivos durante falhas de conexão com o serviço dependente.

### 4. Agregação de Consultas Complexas em Sistemas Distribuídos

- **Desafio Arquitetônico:** O sistema deve ser capaz de processar rapidamente uma consulta complexa que requer a combinação de dados de múltiplas fontes (ex: preço médio atual de réplicas em tempo real e últimas 10 transações históricas de partições de dados) em uma única resposta unificada.
- **Padrão de Projeto Recomendado:** **Scatter/Gather**.
    - **Justificativa (Fonte Aula 15):** O padrão Scatter/Gather é aplicado quando o sistema é replicado ou particionado, e requer que partes do trabalho sejam feitas paralelamente e que as respostas parciais sejam combinadas para formar uma resposta final para o cliente. O componente de raiz (_Root Node_) recebe a requisição, distribui-a para as réplicas ou _shards_, e em seguida combina as respostas. No contexto do sistema de cotações, o Serviço de Agregação de Consultas atua como o nó raiz.

---
Como arquiteto de software, a integração do Sistema de Cotações deve ser estruturada sobre padrões de projeto distribuídos para garantir alta disponibilidade, escalabilidade e comunicação desacoplada. O fluxo de dados de uma nova cotação envolve a aplicação sequencial do padrão **Circuit Breaker** (no produtor), seguido pelo **Publisher/Subscriber** (para distribuição assíncrona) e, finalmente, o **Sharding** (para persistência escalável).

### Conectividade dos Componentes

A arquitetura baseia-se em um modelo de comunicação assíncrona, onde o Serviço de Cotações não mantém conhecimento direto de seus consumidores, promovendo o desacoplamento.

1. **Serviço de Cotações (Produtor/Publisher):** É o nó que inicia o fluxo de dados, gerando a nova cotação. Este serviço se conecta a uma dependência externa (Serviço de Cotações Externo) e ao **Broker** (interno).
2. **Broker (Pub/Sub):** Atua como um intermediário central. Recebe mensagens do Serviço de Cotações (Publisher) e as distribui para todos os consumidores (Subscribers), incluindo o Repositório de Dados Históricos.
3. **Repositório de Dados Históricos (Consumidor/Subscriber/Shards):** Conecta-se ao **Broker** para assinar o tópico de novas cotações. É internamente composto por múltiplos _shards_ (servidores de dados) que são conectados por um roteador ou lógica de aplicação para determinar onde o dado será armazenado.

### Fluxo de Dados: Chegada de uma Nova Cotação

O fluxo inicia no momento em que uma nova cotação é solicitada ou gerada e é concluído com a sua persistência distribuída:

#### 1. Geração da Cotação e Resiliência (Circuit Breaker)

O _Serviço de Cotações em Tempo Real_ é responsável por obter o preço. Dado que ele depende de um serviço externo, ele deve utilizar o padrão **Circuit Breaker** para garantir a disponibilidade do seu próprio serviço.

- **Ação:** O Serviço de Cotações tenta interagir com o serviço externo. O Circuit Breaker atua como um _proxy_ que monitora falhas na comunicação.
- **Controle de Falha (Fonte Aula 15):** Se as requisições falham repetidamente ou excedem um limite (threshold), o Circuit Breaker muda do estado `Closed` para `Open`, interrompendo chamadas subsequentes e prevenindo que os recursos do serviço primário fiquem ocupados esperando _timeouts_ repetitivos.
- **Sucesso:** Assumindo que o serviço externo está funcional, a cotação é obtida ou gerada.

#### 2. Distribuição Assíncrona (Publisher/Subscriber)

Após a obtenção da cotação, ela deve ser difundida de maneira eficiente e sem que o serviço de cotações gerencie ativamente as conexões dos clientes. O padrão **Publisher/Subscriber (Pub/Sub)** resolve este desafio.

- **Publicação (Publisher):** O Serviço de Cotações atua como o **Publisher** e envia a nova cotação como uma mensagem (evento) para um **Tópico** específico dentro do Broker.
- **Desacoplamento (Fonte Designing Distributed Systems):** O Publisher não precisa saber quais clientes (Subscribers) estão interessados na informação, nem gerenciar suas conexões. Essa comunicação é assíncrona e desacoplada.

#### 3. Persistência Escalável (Subscriber/Sharding)

O Repositório de Dados Históricos, configurado como um **Subscriber**, consome a mensagem do tópico para armazenar a transação. Como o repositório é grande e lento, o padrão **Sharding (Particionamento)** é aplicado.

- **Consumo (Subscriber):** O Repositório de Dados Históricos recebe a mensagem (nova cotação/transação) do Broker.
- **Roteamento para Shard (Sharding Function):** Para persistir a cotação, o sistema precisa determinar em qual _shard_ (partição física) o dado deve residir. Isso é feito através de uma **função de Sharding**, que mapeia a chave da cotação (ex: ID do ativo) para um dos servidores de dados. Esta função garante que o dado correto seja enviado para o local adequado para persistência.
- **Persistência:** O _shard_ de destino armazena a nova transação de forma eficiente, mitigando os problemas de escalabilidade e latência inerentes a um único servidor centralizado.

Em resumo, o fluxo garante que a produção de cotações seja resiliente a falhas externas (Circuit Breaker), a distribuição seja instantânea e desacoplada (Pub/Sub), e a persistência seja escalável (Sharding).